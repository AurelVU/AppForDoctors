[
  {
    "Id": "1072863",
    "ThreadId": "451218",
    "Html": "First of all thanks for creating this tool!\r<br />\n<br />\nI am trying to access an .xlsx file with three sheets, each about 4400x50 cells. I would like all data to memory and then loop over the resulting table and select what is needed. Therefore I do:<br />\n<pre><code>private DataSet m_ds = new DataSet;\n...\n\nFileStream fs = File.Open(file, FileMode.Open, FileAccess.Read);\nIExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);\nexcelReader.IsFirstRowAsColumnNames = true;\nm_ds = excelReader.AsDataSet();\nfs.Close();\n...\nforeach (DataTable dt in m_ds[tab].Tables)\n{\n   if (dt.TableName == sheet)\n   {\n      foreach (DataRow r in dt.Rows)\n      {\n         string str = Convert.ToString(r[&quot;Date&quot;]);\n         // access some other columns...\n      }\n   }\n}</code></pre>\n\nI investigated the times required by different operations and I got to the conclusion that the time required for opening is quite small (abt 2 s), but the time required for looping over the DataTables is quite large (abt 15 s). This is a bit of a problem for my application. I am a bit surprised by this since I expected that IO should be slower than access of objects from memory. ...or I completely misunderstood how the DataSet object works. Any explanation for this behavior or how I could improve my code?\r<br />\nThanks in advance,\r<br />\nValentin\r<br />\n<br />\nPS. I am new to C# so comments regarding my implementation are welcome.<br />\n",
    "PostedDate": "2013-07-25T09:13:13.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1072897",
    "ThreadId": "451218",
    "Html": "Opening would include the &quot;m_ds = excelReader.AsDataSet()&quot; line.  I ran a test opening 3 fairly large sheets and loading them in a data grid:\r<br />\n<br />\n13 seconds to load sheets in dataset.\r<br />\n0.003 seconds to load each table in a data grid.\r<br />\n<br />\nI believe the IO occurs in the &quot;m_ds =&quot; line.  I don't see any timing in your code to break out the load time from the data set access time.  Opening the file IO time is minimal.<br />\n\r<br />\nI suggest you put some Stopwatch timers around file open to file close and around the table access.\r<br />\n<br />\nLet me know what you find.<br />\n",
    "PostedDate": "2013-07-25T10:51:19.23-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1073377",
    "ThreadId": "451218",
    "Html": "I am sorry I didn't put the timers on the piece of code posted above. I have already done that. These are more exact results:<br />\n<pre><code>FileStream fs = File.Open(file, FileMode.Open, FileAccess.Read);\nIExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);\nexcelReader.IsFirstRowAsColumnNames = true;\nm_ds = excelReader.AsDataSet();\nfs.Close();\n</code></pre>\n\nThis takes about 2 s. If I understand correctly this is the where the IO takes place. If so, I think this is excellent.<br />\n<pre><code>foreach (DataRow r in dt.Rows)\n                        {\n                            string str = Convert.ToString(r[&quot;Date&quot;]);\n                            DateTime d;\n                            double v;\n                            try\n                            {\n                                if (str.Contains('.'))\n                                {\n                                    d = DateTime.Parse(ControlExcel.ConvertToDateTime(str), provider);\n                                }\n                                else\n                                    d = DateTime.Parse(ControlExcel.ConvertToDateTime(str));\n                                v = Convert.ToDouble(r[p.Key]);\n                            }\n                            catch (Exception theException)\n                            {\n                                continue;\n                            }\n                            dat.Add(d);\n                            val.Add(v);\n                        }</code></pre>\n\nThis takes about 13 s.<br />\n<br />\nMy first thought was that access to the DataTable container is slow. So I tried some alternatives, by copying the contents of the columns I am interested in into List or into System.Array objects. Then I looped over the List/System.Array containers, but the time is exactly the same.<br />\n<br />\nAs a reference, I am comparing to what I observe when using the Microsoft.Office.Interop functionality. In this case, the file access time is comparable. But I only read the columns I am interested in and not the whole workbook (like when using the ExcelDataReader --&gt; this might a big advantage!). I get the colmun data into System.Array objects. Then looping over these containers is very fast (abt 2 seconds), with the same code as in the foreach loop above.<br />\n",
    "PostedDate": "2013-07-26T02:05:12.023-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1073497",
    "ThreadId": "451218",
    "Html": "I think you should pull everything out of your loop but the  string str = Convert.ToString(r[&quot;Date&quot;]); and do something with the str value just to make sure it doesn't get optimized out.  I like the Stopwatch timer outside the loop so it doesn't add any delay inside the loop.\r<br />\n<br />\nI just have a list box on a form that displays the times.  I create the gridviews dynamically for each table.  It's possible I messed up the timing code but I don't see anything like the times your seeing.  Here is the code I used:\r<br />\nusing System;\r<br />\nusing System.Collections.Generic;\r<br />\nusing System.ComponentModel;\r<br />\nusing System.Data;\r<br />\nusing System.Drawing;\r<br />\nusing System.Linq;\r<br />\nusing System.Text;\r<br />\nusing System.Windows.Forms;\r<br />\nusing System.IO;\r<br />\nusing Excel;\r<br />\nusing System.Diagnostics;\r<br />\n<br />\nnamespace ExcelParserFormsTest\r<br />\n{\r<br />\n  public partial class Form1 : Form\r<br />\n  {<br />\n<pre><code>public Form1()\n{\n  InitializeComponent();\n  LoadSheets();\n}\n\nprivate void LoadSheets()\n{\n  Stopwatch swLoad = new Stopwatch();\n  Stopwatch swTot = new Stopwatch();\n  Stopwatch swTbl = new Stopwatch();\n\n  //string _PathFilename = @&quot;C:\\Temp\\test3.xlsx&quot;;\n  string _PathFilename = @&quot;C:\\Temp\\tri_201918.xlsx&quot;;\n  swTot.Start();\n  using (FileStream streamIn = File.Open(_PathFilename, FileMode.Open, FileAccess.Read))\n  using (IExcelDataReader execlReader = (Path.GetExtension(_PathFilename) == &quot;.xlsx&quot; ? ExcelReaderFactory.CreateOpenXmlReader(streamIn) : ExcelReaderFactory.CreateBinaryReader(streamIn)))\n  {\n    swLoad.Start();\n    DataSet ds = new DataSet();\n    ds = execlReader.AsDataSet();\n    swLoad.Stop();\n    lbTimes.Items.Add(&quot;Load &quot; + swLoad.Elapsed.ToString());\n\n    int r = ds.Tables[0].Rows.Count;\n    int c = ds.Tables[0].Columns.Count;\n\n    if (ds.Tables.Count &lt; 1)\n    {\n      MessageBox.Show(&quot;  No sheets in workbook.&quot;);\n    }\n    else\n    {\n      int x = 0, y = 0;\n      foreach (DataTable sheet in ds.Tables)\n      {\n        lbTimes.Items.Add(&quot;Rows &quot; + sheet.Rows.Count.ToString());\n        lbTimes.Items.Add(&quot;Cols &quot; + sheet.Columns.Count.ToString());\n        swTbl.Start();\n        DataGridView dgv = new DataGridView();\n        dgv.Location = new Point(x+=100, y+=100);\n        dgv.DataSource = sheet;\n        this.Controls.Add(dgv);\n        swTbl.Stop();\n        lbTimes.Items.Add(&quot;Table &quot; + swTbl.Elapsed.ToString());\n      }\n    }\n  }\n  swTot.Stop();\n  lbTimes.Items.Add(&quot;Tot &quot; + swTot.Elapsed.ToString());\n}</code></pre>\n\n}\r<br />\n}<br />\n",
    "PostedDate": "2013-07-26T07:09:24.697-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1074301",
    "ThreadId": "451218",
    "Html": "Ok I figured out what was slowing things down. It was the part which was parsing the date/time string to a DateTime object. \r<br />\nUsing the Microsoft.Office.Interop functionality, the value of the cell converted to a string gives a &quot;number&quot; (e.g., &quot;35432&quot; etc.), while using the ExcelDataReader returns a date string (e.g., &quot;1/2/1997 12:00:00 AM&quot;). In the latter case I had to change a little bit my code and I achieved again quite fast times around the foreach loop. Around 2s, which is ok for my application.\r<br />\nThanks for the discussion!\r<br />\nRegards,\r<br />\nValentin<br />\n",
    "PostedDate": "2013-07-29T06:30:17.573-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]